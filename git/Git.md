## Как склеить коммиты

1. Узнаем сколько коммитов надо склеить 
`git cherry -v master | wc -l`
1. Переписываем историю на число коммитов из предыдущей команды
`git rebase -i HEAD~5` или `git rebase -i master`. В интерактивном режиме самый верхний коммит должен быть `pick`.  Он самый ранний и к нему буду приклеиватся остальные.
1. Так как история изменилась на сервер пушим с форсом 
`git push --force`

---

## Просим git игнорировать изменения прав файлов (chmod)
`git config core.fileMode false`
То же самое с флагом `--global` чтобы настройка применялась для всех репозиториев (использует ~/.gitconfig вместо .git/config)

---

## error: The following untracked working tree files would be overwritten by merge
Remote файлы несовпадают с локальными. Перепишем в пользу удаленных
```bash
git fetch --all
git reset --hard origin/master
```

## Переименовать удалённую ветку
Предположим, что у вас есть ветка oldname. Вы запушили (push) ее на удаленный репозиторий. Теперь вы хотите переименовать ее, чтобы она называлась newname.
1. Переключиться на ветку, которую вы хотите переименовать.
1. Переименовать локальную ветку командой: 
`bash git branch -m oldname newname`
1.  Удалить удаленную (remote) ветку (oldname), которую вы хотите переименовать:
`git push origin :oldname`
1. Загрузить (push) переименованную ветку newname в удаленный репозиторий:
`git push origin -u newname`

---

## Склонировать в текущаю папку не создавая имя репозитория
`git clone https://github.com/napastyuk/md.git .`

---

## Относительные ссылки на коммиты
Указание на коммит при помощи его хеша - не самый удобный способ, поэтому Git поддерживает относительные ссылки. 
`git checkout main^`  	означает "первый родитель ветки `main`"
`git checkout main^^` 	означает прародитель (родитель родителя) `main`
`git checkout HEAD^` 	означает первый родитель ветки указателя HEAD. То есть по сути "на один коммит назад во времени"
`git checkout HEAD~2` 	означает переместить указатель HEAD на 2(может быть любым числом) коммита назад
`git checkout -` переключение на ветку на которой вы находились раньше
`git checkout @{-1}` переключение на одну(может быть любым числом) ветку назад  
`git checkout --`  `--` дает команду для checkout что все дальнейшие команды это НЕ опции для checkout. Обычно используется что бы перехать путь до файла, если нужно выполнить команду над отдельным файлом
`git checkout -- filename ` без аргументов - откатить состояние filename до последнего комита(но только если он еще не добавлен в stage или commit)

`git branch -f main HEAD~3`  создать из текущей ветки main , такую же ветку но таккую какой она была 3 коммита назад. Т е принудительно откатить ветку на 3 комита назад.  Что бы 2 коммита не "повисли", можно сначала создать ветку в текущем комите

---

## Отмена изменений

#### Если еще не добавлял в stage
`git checkout -- .` - переместить все файлы в состояние последнего комита. 
`git reset --hard` -  скинуть все файлы до состояния последнего коммита, в том числе изменения в stage 

#### Если уже добавил в stage
`git reset` перемещение указателя. Изменения останутся в файлах, но уйдут из stage и commit, т е полностью уйдут из истории гита. Сами измененяи можно будет откатить через `git restore file` или `git checkout -- file`.

Пример:
`git reset HEAD~1` - откатить все на один коммит назад
`git reset HEAD path/to/file` убрать из stage случайно добавленный файл и вернуть его в исходное состояние.

#### Если уже вылил в remote ветку
`git revert` это создание нового коммита, который отменяет изменения, внесенные другими коммитами.


### Rebase
`git rebase BranchName` - пермещает комиты из текущей ветки поверх ветки BranchName. То есть
1. Ищется общий коммит текущей ветки и BranchName. Он будет точкой отсчёта
2. Дальше последовательно берётся комиты из текущей ветки и применяется сверху ветки BranchName.  Поэтому если хочешь вылить *в мастер*,  аргументом надо указывать *master* , а находит при этом в *feature* 
Можно еще так `git rebase `

---

## Копирование комитов
`git cherry-pick <Commit1> <Commit2> <...>` - очень простой и прямолинейный способ сказать, что ты хочешь копировать несколько коммитов на место, где сейчас находишься (`HEAD`)