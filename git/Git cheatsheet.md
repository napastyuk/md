## Как склеить коммиты

1. Узнаем сколько коммитов надо склеить 
`git cherry -v master | wc -l`
1. Переписываем историю на число коммитов из предыдущей команды
`git rebase -i HEAD~5` или `git rebase -i master`. В интерактивном режиме самый верхний коммит должен быть `pick`.  Он самый ранний и к нему буду приклеиваться остальные.
1. Так как история изменилась на сервер пушим с форсом 
`git push --force`

---

## Просим git игнорировать изменения прав файлов (chmod)
`git config core.fileMode false`
То же самое с флагом `--global` чтобы настройка применялась для всех репозиториев (использует ~/.gitconfig вместо .git/config)

---

## error: The following untracked working tree files would be overwritten by merge
Remote файлы несовпадают с локальными. Перепишем в пользу удаленных
```bash
git fetch --all
git reset --hard origin/master
```

---

## Переименовать удалённую ветку
Предположим, что у вас есть ветка oldname. Вы запушили (push) ее на удаленный репозиторий. Теперь вы хотите переименовать ее, чтобы она называлась newname.
1. Переключиться на ветку, которую вы хотите переименовать.
1. Переименовать локальную ветку командой: 
`bash git branch -m oldname newname`
1.  Удалить удаленную (remote) ветку (oldname), которую вы хотите переименовать:
`git push origin :oldname`
1. Загрузить (push) переименованную ветку newname в удаленный репозиторий:
`git push origin -u newname`

---

## Склонировать в текущую папку не создавая имя репозитория
`git clone https://github.com/napastyuk/md.git .`

---

## Относительные ссылки на коммиты
Указание на коммит при помощи его хеша - не самый удобный способ, поэтому Git поддерживает относительные ссылки. 
`git checkout main^`  	означает "первый родитель ветки `main`"
`git checkout main^^` 	означает прародитель (родитель родителя) `main`
`git checkout HEAD^` 	означает первый родитель ветки указателя HEAD. То есть по сути "на один коммит назад во времени"
`git checkout HEAD~2` 	означает переместить указатель HEAD на 2(может быть любым числом) коммита назад
`git checkout -` переключение на ветку на которой вы находились раньше
`git checkout @{-1}` переключение на одну(может быть любым числом) ветку назад  
`git checkout --`  `--` дает команду для checkout что все дальнейшие команды это НЕ опции для checkout. Обычно используется что бы переехать путь до файла, если нужно выполнить команду над отдельным файлом
`git checkout -- filename ` без аргументов - откатить состояние filename до последнего коммита (но только если он еще не добавлен в stage или commit)

`git branch -f main HEAD~3`  создать из текущей ветки main , такую же ветку но такую какой она была 3 коммита назад. Т е принудительно откатить ветку на 3 коммита назад.  Что бы 2 коммита не "повисли", можно сначала создать ветку в текущем коммите

---

## Отмена изменений

| Команда        | Область действия  | Примеры использования                                                      |
| -------------- | ----------------- | -------------------------------------------------------------------------- |
| `git reset`    | На уровне коммита | Отмена коммитов в частной ветке или сброс изменений, не попавших в коммиты |
| `git reset`    | На уровне файла   | Удаление файла из индекса                                                  |
| `Git checkout` | На уровне коммита | Переключение между ветками или проверка старых снимков состояния           |
| `Git checkout` | На уровне файла   | Отмена изменений в рабочем каталоге                                        |
| `git revert`   | На уровне коммита | Отмена коммитов в публичной ветке                                          |
| `git revert`   | На уровне файла   | На уровне файла не выполняется                                                                      |


#### Если еще не добавлял в stage
`git checkout -- .` - переместить все файлы в состояние последнего комита. 
`git reset --hard` -  скинуть все файлы до состояния последнего коммита, в том числе изменения в stage 

#### Если уже добавил в stage
`git reset` перемещение указателя. Изменения останутся в файлах, но уйдут из stage и commit, т е полностью уйдут из истории гита. Сами измененяи можно будет откатить через `git restore file` или `git checkout -- file`.

Пример:
`git reset HEAD~1` - откатить все на один коммит назад
`git reset HEAD path/to/file` убрать из stage случайно добавленный файл и вернуть его в исходное состояние.

#### Если уже вылил в remote ветку
`git revert` это создание нового коммита, который отменяет изменения, внесенные другими коммитами.


### Rebase
`git rebase BranchName` - пермещает комиты из текущей ветки поверх ветки BranchName. То есть
1. Ищется общий коммит текущей ветки и BranchName. Он будет точкой отсчёта
2. Дальше последовательно берётся комиты из текущей ветки и применяется сверху ветки BranchName.  Поэтому если хочешь вылить *в мастер*,  аргументом надо указывать *master* , а находит при этом в *feature* 
Можно еще так `git rebase `

---

## Копирование комитов
`git cherry-pick <Commit1> <Commit2> <...>` - очень прямолинейный способ сказать, что ты хочешь копировать несколько коммитов на место, где сейчас находишься (`HEAD`)

---

## Поиск по истории коммитов
```console
git log --pretty=format:"%h - %an, %ar : %s" --no-merges -S"Hello, World!"
```
Полезные параметры
`--pretty=format:"%h - %an, %ar : %s"` - форматирование вывода списка коммитов
`--no-merges` - не показывать коммиты слияния
`-S"Hello, World!"` - только коммиты которые содержат Hello wold в изменённых строчках
`-G"Hello, World*"` - тоже только для поиск по маске
Другие https://devhints.io/git-log

---

## Запушить новую локальную ветку на сервер
`git push -u origin Название_ветки`

---

## Удалить ветку локально
`git branch --delete Название_ветки`
или
`git branch -D Название_ветки`


#git #cheatsheet 