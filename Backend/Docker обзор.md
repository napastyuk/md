Главное не путать образ контейнера и сам контейнер. 

`Dockerfile` -  образ контейнера,  набор инструкций для сборки контейнера.  Это только заготовка на основе которой можно быстро запускать один или несколько контейнеров.  Физически он (для windows 10) хранится в недрах wsl.  Например для  windows 10 c wsl2 `\\wsl.localhost\docker-desktop-data\version-pack-data\community\docker\image\overlay2` .  Благодаря  `Dockerfile` нужные виртуалки можно создавать декларативными инструкциями.  

`Контейнер`  - экземпляр образа. Он может создаваться, запускаться и уничтожатся в разы быстрее чем обычная виртуалка, потому что эмулирует меньше слоев гостевой ОС.  Из одного образа можно создавать много контейнеров.

## Управление образами / images

```bash
docker build -t "some_container_name" . #  Запуск сборки Dockerfile. Точка в конце команды - это указание что `Dockerfile` надо искать в текущей папке

docker images  # Список уже собранных образов

docker rmi id/name # удаление образа
```

## Управление контейнерами

```bash
docker run "some_container_name"  # запуск контейнера

docker ps  -a # список контейнеров, без префикса a выведутся только запущенные

docker stop id/name # остановка контейнера

docker restart id/name # перезапуск контейнера

docker rm #удаление контейнера
```


## Взаимодействие с docker контейнерами
Как и в виртуалках, по умолчанию docker запускается полностью изолированно от хостовой системы.  Для того чтобы с ним взаимодействовать есть 3 способа: сетевые запросы, запуск команд внутри контейнера и расшаренная папка.

### Сетевые запросы
Для сетевых запросов, нужно при запуске контейнера "опубликовать" порт ключом `--publish` или `-p`
```bash
docker run -d -p 80:80 "some_container_name"
```
Теперь при отправке запросов на localhost эти запросы будут "улетать" в докер. Это называют "мапинг"/"проброс"/"сопоставление" портов

### Запуск терминала внутри контейнера:
```bash
docker exec -it container_name sh
```
`-t` - создать псевдо-терминал в контейнере и подключится к нему 
`-i` - подключение будет интерактивным, т е  после выполнения команды будет ожидаться ввод следующей
`--user guest` - запустить команду от имени пользователя guest
`-e TEST=sammy` - задать env переменную в контенере
выход из контейнера по команде `exit`

### Расшаренная папка / Volume






## Docker compose - управление несколькими контейнерами сразу

Выполняются папке с файлом `docker-compose.yaml`
```bash
docker-compose build # сборка проекта из одного или нескольких контейнеров

docker-compose up -d # запуск проекта синхронно -d в фоне (detached mode)

docker-compose images # список образов которые используются в запущенных контейнерах

docker-compose ps -a # список контейнеров, ключ а по аналогии с docker ps

docker-compose exec [service name] [command] # выполнить команду в контейнере(по аналогии с командой docker)

docker-compose stop

docker-compose down # остановка проекта и удаление контейнеров

docker-compose down --rmi all --volumes # остановить и удалить контейнера(containers), образа(images) и хранилища(volums) связанные с данным docker-compose
```


Отдельно volums можно проверить и удалить вот этой командой
```bash
docker volume ls -f dangling=true # вывести список
docker volume prune # удаление
```




