Главное не путать термины

`Dockerfile` — это текстовый файл с декларативными инструкциями для сборки `image` (образа). Каждая инструкция — это команда для создания одного `layer` (слоя).

`Layer` (слой) — из одной инструкции в Dockerfile создается один слой. Это набор, который состоит из указанных в инструкции файлов и метаданных. Все это упаковано в tar-архив. Один такой слой может вносить только одно конкретное изменение в файловую систему. Однако слой можно сделать неизменяемым и закешировать для повторного использования. Изменения добавляются к предыдущему слою. Самый первый слой, на который накладываются все последующие, называется базовым. Обычно это один из дистрибутивов Linux.

`Image` (образ) — это архивированный набор слоев. Применяя их последовательно, можно создать систему с нужными настройками. В этом смысле это похоже на Git с его системой коммитов. Однако `image` — это не виртуальная машина. Так как каждый слой представляет собой готовую к выполнению команду, образ — это законченный и готовый набор таких команд. Образ можно загрузить в репозиторий образов, например, в `Docker Hub`. Процесс создания образа из Dockerfile называется сборкой образа. Образ можно скачать из репозитория на любой компьютер и создать из него нужное количество экземпляров контейнеров.

`Container` (контейнер) — это запущенный образ. В процессе запуска сам `image` остается неизменным, а на его основе (по его инструкциям) создается экземпляр контейнера. Контейнер — это изолированная среда, работающая как отдельный процесс, с использованием ядра операционной системы хоста. В отличие от обычных виртуальных машин, контейнеры основаны на неизменяемом образе. Если возникают проблемы, контейнер можно перезапустить, и он "забудет" все изменения, внесенные в файловую систему во время его работы. Это позволяет легко масштабировать приложения, создавая дополнительные контейнеры при высокой нагрузке, или быстро пересоздавать контейнеры в случае ошибок. Так как в основе лежит один и тот же `Dockerfile`, это обеспечивает воспроизводимость нужного окружения на любой операционной системе.

## Управление образами / images

```bash
docker build -t "some_container_name" . #  Запуск сборки Dockerfile. Точка в конце команды - это указание что `Dockerfile` надо искать в текущей папке

docker images  # Список уже собранных образов

docker rmi id/name # удаление образа
```

## Управление контейнерами

```bash
docker run "some_container_name"  # запуск контейнера

docker ps  -a # список контейнеров, без префикса a выведутся только запущенные

docker stop id/name # остановка контейнера

docker restart id/name # перезапуск контейнера

docker rm #удаление контейнера
```


## Взаимодействие с docker контейнерами
Как и в виртуалках, по умолчанию docker запускается полностью изолированно от хостовой системы.  Для того чтобы с ним взаимодействовать есть 3 способа: сетевые запросы, запуск команд внутри контейнера и расшаренная папка.

### Сетевые запросы
Для сетевых запросов, нужно при запуске контейнера "опубликовать" порт ключом `--publish` или `-p`
```bash
docker run -d -p 80:80 "some_container_name"
```
Теперь при отправке запросов на localhost эти запросы будут "улетать" в докер. Это называют "мапинг"/"проброс"/"сопоставление" портов

### Запуск терминала внутри контейнера:
```bash
docker exec -it container_name sh
```
`-t` - создать псевдо-терминал в контейнере и подключится к нему 
`-i` - подключение будет интерактивным, т е  после выполнения команды будет ожидаться ввод следующей
`--user guest` - запустить команду от имени пользователя guest
`-e TEST=sammy` - задать env переменную в контенере
выход из контейнера по команде `exit`

### Расшаренная папка / Volume






## Docker compose - управление несколькими контейнерами сразу

Выполняются папке с файлом `docker-compose.yaml`
```bash
docker-compose build # сборка проекта из одного или нескольких контейнеров

docker-compose up -d # запуск проекта синхронно -d в фоне (detached mode)

docker-compose images # список образов которые используются в запущенных контейнерах

docker-compose ps -a # список контейнеров, ключ а по аналогии с docker ps

docker-compose exec [service name] [command] # выполнить команду в контейнере(по аналогии с командой docker)

docker-compose stop

docker-compose down # остановка проекта и удаление контейнеров

docker-compose down --rmi all --volumes # остановить и удалить контейнера(containers), образа(images) и хранилища(volums) связанные с данным docker-compose
```


Отдельно volums можно проверить и удалить вот этой командой
```bash
docker volume ls -f dangling=true # вывести список
docker volume prune # удаление
```

Docker Desktop устанавливает 2 внутренних дистрибутива Linux специального назначения docker-desktop и docker-desktop-data. Первый (docker-desktop) используется для запуска ядра Docker (dockerd), а второй (docker-desktop-data) хранит контейнеры и образы. Ни то, ни другое нельзя использовать для общего развития.




