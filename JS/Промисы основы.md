Допустим нам надо сделать какую-то операцию, такую что она 
1) длится некоторoе ненулевое время
2) теоретически может завершится ошибкой и желательно ошибку как-то обработать
3) возможно нужно будет повторить операцию несколько раз

Что бы не замораживать интерфейс на время выполнения этой операции нам придется
1) сделать ее асинхронно
2) по итогам выполнения вызвать обработчик ошибки или обработчик успеха
3) применить chaining/цепочки для удобной записи последующих операций

```javascript
function doSomeOperation((whatToDoInCaseOfSuccess, whatToDoInCaseOfFail)=>{
	//делаем какую-то медленную и непредсказуемую операцию
	//проверяем что выполнилась успешно
	if(allRight) {
		//делаем что долны в случае успеха 
	} else {
		//делаем что должны в случае ошибки
	}
});
```

То же самое в синтаксисе Promis

```javascript
//подготовилсь к медленной операции

function doSomeOperation() {	
	return new Promise((resolve, reject)=>{
		//делаем какую-то медленную и непредсказуемую операцию
		if(allRight) resolve('все ок')
		else reject('что-то пошло не так')
	})		
}

var result = doSomeOperation();
result.then(successCallback, failureCallback);
```

#js #promise
