### Относительные ссылки на коммиты
Указание на коммит при помощи его хеша - не самый удобный способ, поэтому Git поддерживает относительные ссылки. 
`git checkout main^`  	означает "первый родитель ветки `main`"
`git checkout main^^` 	означает прародитель (родитель родителя) `main`
`git checkout HEAD^` 	означает первый родитель ветки указателя HEAD. То есть по сути "на один коммит назад во времени"
`git checkout HEAD~2` 	означает переместить указатель HEAD на 2(может быть любым числом) коммита назад
`git checkout -` переключение на ветку на которой вы находились раньше
`git checkout @{-1}` переключение на одну(может быть любым числом) ветку назад  
`git checkout --`  `--` дает команду для checkout что все дальнейшие команды это НЕ опции для checkout. Обычно используется что бы перехать путь до файла, если нужно выполнить команду над отдельным файлом
`git checkout -- filename ` без аргументов - откатить состояние filename до последнего комита(но только если он еще не добавлен в stage или commit)

`git branch -f main HEAD~3`  создать из текущей ветки main , такую же ветку но таккую какой она была 3 коммита назад. Т е принудительно откатить ветку на 3 комита назад.  Что бы 2 коммита не "повисли", можно сначала создать ветку в текущем комите


### Отмена изменений

#### Если еще не добавлял в stage
`git checkout -- .` - переместить все файлы в состояние последнего комита. 
`git reset --hard` -  скинуть все файлы до состояния последнего коммита, в том числе изменения в stage 

#### Если уже добавил в stage
`git reset` перемещение указателя. Изменения останутся в файлах, но уйдут из stage и commit, т е полностью уйдут из истории гита. Сами измененяи можно будет откатить через `git restore file` или `git checkout -- file`.

Пример:
`git reset HEAD~1` - откатить все на один коммит назад
`git reset HEAD path/to/file` убрать из stage случайно добавленный файл и вернуть его в исходное состояние.

#### Если уже вылил в remote ветку
`git revert` это создание нового коммита, который отменяет изменения, внесенные другими коммитами.







### Rebase
`git rebase BranchName` - пермещает комиты из текущей ветки поверх ветки BranchName. То есть
1. Ищется общий коммит текущей ветки и BranchName. Он будет точкой отсчёта
2. Дальше последовательно берётся комиты из текущей ветки и применяется сверху ветки BranchName.  Поэтому если хочешь вылить *в мастер*,  аргументом надо указывать *master* , а находит при этом в *feature* 
Можно еще так `git rebase `

### Копирование комитов
`git cherry-pick <Commit1> <Commit2> <...>` - очень простой и прямолинейный способ сказать, что ты хочешь копировать несколько коммитов на место, где сейчас находишься (`HEAD`)