Для настройки Content Security Policy ( далее CSP) необходимо постоянно редактировать заголовки, приходящие с сервера. Рассмотрим некоторые сложности которые могут возникнуть.

## 1. Настройка заголовков на mac/linux через nginx
Поднимаем локально nginx, заворачиваем локальный сервер и редактируем заголовки из конфигурации nginx. Это более простой способ.
Локальный сервер из webpack-а `webpack-dev-server` не поможет, так как нам нужен механизм nginx по обработке статики, а webpack-dev-server так не умеет.
Сам механизм настройки прекрасно описан [тут](https://habr.com/ru/articles/757332/) . Я раскрою только то, чего нет в статье.

## 2. Настройка на Windows или альтернативный способ
Если у вас Windows или проект не получается направить на локальный nginx, тогда поможет резервный вариант в виде CSP тегов в HTML и немного костылей.
Спецификация CSP позволяет вместо заголовков пользоваться тегом `<meta>`(https://content-security-policy.com/examples/meta/ ). Но если в запросе одновременно заголовки и тег, то браузер отдаёт приоритет заголовку. Для защиты чуть больше чем дефолтная, нам нужен будет механизм nonce. Если сильно упрощать, это когда в CSP заголовке указывается секретный код (`nonce`). А дальше весь HTML проверяется. Если у тега `script` есть HTML атрибут `nonce="secter_code"`, то это доверенный скрипт или стиль. А если нет атрибута, то это скрипт, добавленный злодеем, и его нельзя выполнять. А в следующем запросе nonce уже должен быть другим, то есть генерироваться под каждый запрос.
К тегам style все это тоже относится, потому что в скриптах через директиву `content` можно добавлять SVG, а внутри SVG может быть зловредный JS. 

## 3. Настройка nonce
Если у вас не получилось завернуть локальный проект в nginx, то только для локальной разработки, можно сделать так - вбить в CSP meta-тег один фиксированный nonce и для отладки использовать его. Главное потом, перед выкаткой на продакшн, не забудьте пройтись поиском по проекту и заменить тестовый nonce на продовый. Что-то вроде такого:
```html
<meta http-equiv="Content-Security-Policy" content="default-src 'self'">
```

## 4. Проверка и отладка
Если вы выполните все по инструкции и обнаружите, что в dev tools браузера атрибут nonce показывается но без значения, например `<style nonce>` вместо `<style nonce="your_secret">`, то это значит, что вы настроили все правильно! Браузеры скрывают значение nonce для безопасности. 

После того, как вы настроите заголовки, начнется самый интересный этап: ходить по сайту и смотреть, где что отвалилось. Хром заботливо подсказывает все места, где он не выполнял ресурс из-за CSP, на панели [issues](https://developer.chrome.com/docs/devtools/issues?hl=ru).

## 5. Работа с внешними библиотеками
После того, как вы внедрили nonce в свой основной бандл, следующая сложность обычно в том, что на крупных сайтах блоки стилей и скриптов вы добавляете не напрямую. Их добавляют UI компоненты, которые у вас подключены. Здесь возможно несколько вариантов:
- Пойти в настройку библиотеки и найти там настройку CSP nonce. Если она там есть.
- Попробовать выключить в настройках создание дополнительных блоков script/style.
- Пойти в GitHub issue, поискать там по слову CSP и выяснить, есть ли workaround для вашего случая.
- Если стили/скрипты не меняются от клиента к клиенту, то можно скопировать их в свой бандл. CSP ошибки конечно будут висеть, но код выполняться будет, потому что свой бандл у вас подписан. Просто выполняться будут не те стили/скрипты, которые попыталась добавить библиотека (они будут заблокированы CSP), а ваш дублирующий код.
- Отказаться от библиотеки и перейти на другую, которая все таки использует CSP. Тут все зависит от того, сколько придется переписать кода под новую библиотеку.
- Если ничего не помогает, а библиотека нужна, то можно добавить блок, который она генерирует, в sha256. Но если что-то поменяется (даже если CDN решит убрать один пробел), то sha256 не совпадет и скрипт/стиль заблокируется. Поэтому этот способ используется редко. Но если у вас нет агрессивных CDN, то нужный код sha256 для вашего блока можно взять прям из dev tools. Код sha256 будет  упомянут в коде CSP ошибки. В вообще там еще указывается, где находится в DOM заблокированный блок. Очень удобно для дебага.

Материалы по CSP:
- https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html
- https://content-security-policy.com/
- https://developer.mozilla.org/ru/docs/Web/HTTP/CSP

Пример конфига:
```nginx
sub_filter_once off;   
#По умолчанию sub_filter заменяет первое вхождение строки в тексте. С помощью sub_filter_once off; все вхождения строки будут заменены
sub_filter **CSP_NONCE** $request_id;  
# строчка `**CSP_NONCE**` во всех статик файлах будет заменена на уникальный идентификатор запроса ($request_id)
# $request_id используется в качестве уникального nonce для CSP	
# Добавляем заголовок Content-Security-Policy к ответу сервера
# Синтаксис. Значение заголовка обрамляется в " " .Значение состоит из разных директив разделённых ;
														
														
add_header Content-Security-Policy "default-src 'none';   # default-src 'none' - по умолчанию запрещаем вообще все. То что можно будет перечислено ниже  
                   script-src 'self' 'nonce-$request_id' 'strict-dynamic';   # Разрешает загрузку скриптов только с текущего домена ('self'), а также скриптов с html атрибутом nonce, равным $request_id. Директива 'strict-dynamic' позволяет скриптам, которые уже разрешены, загружать другие скрипты. 
                   style-src 'self' 'nonce-$request_id'	# Аналогично 
                             'sha256-47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU='  # только добавляется разрешение за запуск одного конкретного блока <style> c конкретным sha256
                   img-src 'self' data:;   # Разрешает загрузку изображений только с текущего домена и данных, закодированных в URL (например, data:image/png;base64,...). В data часто кодируют небольшие растровые иконки. 
                   frame-ancestors 'none';   # По идее закрывается default-src 'none', но на всякий случай продублировали. Запрещает встраивание страницы в <frame>, <iframe>, <object>, <embed> или <applet> на других сайтах. 
                   object-src 'none';  # Аналогично. Запрещает загрузку плагинов, таких как Flash
                   connect-src 'self' https://example.com/;  # Разрешает подключения (например, через WebSockets, EventSource или Fetch) только к текущему источнику и указанным URL. ПО идее домен с /api дублировать не нужно, но видимо на всякий случай. 
                   upgrade-insecure-requests;  # Даже если скрипт попытается установить http соединение, соединение принудительно обновят до https 
                   block-all-mixed-content;  # То же самое. Если будет запрошен (например через img src ) ресурс по http, запрос не пройдет
                   font-src 'self';  # В CSS @font-face scr шрифт можно будет загрузить только с текущего домена		
                   media-src 'self';  # тоже про теги audio src и аналогичных
                   base-uri 'self';  # защищает от атаки когда в html Добавляется <base href="https://example.com/hackedDirectory/"> и все относительные URL начинают резолвится относительно него												
                   " always; # слово always после закрытой кавычки указывает, что заголовок Content-Security-Policy должен быть добавлен всегда, даже если ответ имеет код статуса ошибки (например, 404, 500 и т.д.). 
```