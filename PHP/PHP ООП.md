---
tags:
  - ооп
  - oop
---
## Класс и объект 

Объект - это сущность у которой есть
- состояние (характеризуется набором свойство и значений)
- поведение (возможное поведение и реакция)
- уникальность (способ определить переменная указывает на один объект или на разные )

Класс - это прототип/шаблон для объекта. Он определяет набор методов , переменных и их начальное значение. 

К переменных объекта можно обращаться через `$this`  .  В разных экземплярах this будет указывать на конкретный экземпляр объекта. 
```php
class Artile
{
 public $title;

 public function view() {
	 return $this->title
 }
}
```

Объект создается из класса с помощью оператора `new`
```php
$myArticle = new Article;
$myArticle->title = "123"; //обращение к свойствам класса
$myArticle->view();        //обращение к методам класса  
```
Важно. `$this` - это обращение именно к объекту.  Для обращения к классу используется другое ключевое слово `self` (про него ниже)

Для более удобного создания используется функция конструктор , которая вызывается всегда при `new`
```php
class One 
{
    public function __constructor() {
    }
}
```
Конструктор может использовать другие функции и переменные, их помечают `static` чтобы они были недоступны в готовом объекте (подробнее про static ниже)
```php
class One  {
	privat static $secret = "123";
	privat static function doIt() {
	}
}
```

## ООП базовые принципы. 

**Инкапсуляция** - скрытие деталей реализации и выставление наружу только специальных методов (интерфейса)

**Наследование** - когда одни класс использует структуру или поведение другого класса

**Полиморфизм** - способность класса порождать похожие объекты в зависимости от ситуации. Делается через абстрактные классы в которые выносятся общие методы, а в конкретных классах методы доопределяются до специфичных.  

При наследовании конкретные дочерние классы используют более общие родительские методы. 
А в полиморфизме наоборот общие родительские классы используют частные дочерние методы чтобы быть подстраиваться под конкретный вызов в коде.     

## Пример наследования
```php
class Article
{
 $title="One";	
 function view() {
 }
 //теперь метод можно вызывать так $this->view()
}

class SpecialArticle extends Article //класс SpecialArticle наследует класс Article
{
  
  function view() {
	 echo parent::$title //One , потому что это ссылка на родительский класс
	 
	 echo self::$title //One , потому что это ссылка на тот класс в котором переменная описана. 
	 //Так как в SpecialArticle $title не описан, выводится значение из класса где $title описан.
  }
}

```

Теперь метода `view()` у нас в двух местах.  Там где метод описан ( **Article** ) и там где метод вызван ( **SpecialArticle** ).   В обоих классах могут быть переменных с одинаковыми именами ( `$title` ).  Чтобы уточнить к какой именно переменной ( дочерней или родительской) нам нужен доступ в методе `view()` есть ключевые слова `self` и `parent`

## Static методы и переменные

**static** - ключевое слово ставится перед переменной или методом. Статические переменные/метод создаются одни раз (при первом вызове класса) и остаются в области видимости класса, не распространяясь на объекты созданные этим классом.  Нестатические методы создаются для каждого нового созданного объекта. Это удобно не надо менять состояние класса , а нужно просто выполнить действие или проинициализировать объект при его создании.  

Вызов обычной переменной/метода 
```php
public $name;
//...
echo $this->name;
```

Вызов статической переменной/метода
```php
static $name;
//...
echo self::$name;
```

Можно еще использовать `static::$name;`
Тогда учтутся `static` переменные определённые в данном классе.  Это гораздо удобнее чем `self::` , потому что `self::` по сути запрещает переопределение в дочерних классах , а через `static` можно переопределить родительские методы в классе, не жертвуя закрытым режимом для объекта.      

## Область видимости свойств / методов / констант

Нужна чтобы реализовать инкапсуляцию 
`public` - доступ разрешён отовсюду 
`protected` - разрешён самому классу и его наследникам
`private` - доступ только внутри самого класса


## Пространство имён
Создание
```php
/*person.php*/
namespace base

class Person
{
}
```

Обращение
```php
include "person.php";
$tom = new \base\Person()
//или
use \base\classes\Person as User
```

Пространства имён могут быть вложенными 

Подключать можно не только классы, но и константы и функции
```php
use \base\classes\Person;
use const \base\classes\adminName;
use function \base\classes\printPerson;

```
