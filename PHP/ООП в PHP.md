#php/ооп
## Класс и объект 

Объект - это сущность у которой есть
- состояние (характеризуется набором свойство и значений)
- поведение (возможное поведение и реакция)
- уникальность (способ определить переменная указывает на один объект или на разные )

*Важно! В контексте ООП , объект это не структура данных, а экземпляр который порождается классом!*

Класс - это прототип/шаблон для объекта. Он определяет набор методов , переменных и их начальное значение. 
К переменных объекта можно обращаться через `$this`  .  В разных экземплярах this будет указывать на конкретный экземпляр объекта. 
```php
class Artile
{
 public $title;

 public function view() {
	 return $this->title
 }
}
```
Важно. `$this` - это обращение именно к объекту.  Для обращения к классу используется другое ключевое слово `self` (про него ниже).

Объект создается из класса с помощью оператора `new`
```php
$myArticle = new Article;
$myArticle->title = "123"; //обращение к свойствам класса
$myArticle->view();        //обращение к методам класса  
```

Для более удобного создания используется функция конструктор , которая вызывается всегда при `new`
```php
class One 
{
    public function __constructor() {
    }
}
```
Конструктор может использовать другие функции и переменные, их помечают `static` чтобы они были недоступны в готовом объекте 
```php
class One  {
	privat static $secret = "123";
	privat static function doIt() {
	}
}
```
Подробнее про `static` [Static методы и переменные](#Static%20методы%20и%20переменные) .

Удаляются объекты с помощью функции `unset`;
```php
unset($myArticle); 
```

## ООП базовые принципы. 

**Инкапсуляция** - скрытие деталей реализации и выставление наружу только специальных методов (интерфейса)

**Наследование** - когда одни класс использует структуру или поведение другого класса

**Полиморфизм** - способность класса порождать похожие объекты в зависимости от ситуации. Делается через абстрактные классы в которые выносятся общие методы, а в конкретных классах методы доопределяются до специфичных.  

При наследовании конкретные дочерние классы используют более общие родительские методы. 
А в полиморфизме наоборот общие родительские классы используют частные дочерние методы чтобы быть подстраиваться под конкретный вызов в коде.     

## Пример наследования
```php
class Article
{
 $title="One";	
 function view() {
 }
 //теперь метод можно вызывать так $this->view()
}

class SpecialArticle extends Article //класс SpecialArticle наследует класс Article
{
  
  function view() {
	 echo parent::$title //One , потому что это ссылка на родительский класс
	 
	 echo self::$title //One , потому что это ссылка на тот класс в котором переменная описана. 
	 //Так как в SpecialArticle $title не описан, выводится значение из класса где $title описан.
  }
}

```

Теперь метода `view()` у нас в двух местах.  Там где метод описан ( **Article** ) и там где метод вызван ( **SpecialArticle** ).   В обоих классах могут быть переменных с одинаковыми именами ( `$title` ).  Чтобы уточнить к какой именно переменной ( дочерней или родительской) нам нужен доступ в методе `view()` есть ключевые слова `self` и `parent`

## Модификаторы доступа
Определяют доступ к методам и переменных в классах. Реализуют инкапсуляцию. 
- **private** – доступны только внутри этого класса, недоступны в классах-наследниках;
- **protected** – доступны внутри этого класса и всем классам-наследникам. При этом недоступны все остальным классам, которые не-наследники.
- **public** – доступны как внутри объектов класса, так и снаружи – можем напрямую обращаться к ним извне. Доступны классам-наследникам.

## Static методы и переменные

**static** - ключевое слово ставится перед переменной или методом. Статические переменные/метод создаются одни раз (при первом вызове класса) и остаются в области видимости класса, не распространяясь на объекты созданные этим классом.  Переменные сохраняют свое состояние между созданиями экземпляров класса. 
Нестатические методы создаются для каждого нового созданного объекта. Их переменные создаются заново для каждого экземпляра.  

Статические методы удобно использовать для хелперов или других функций которые не влияют на другие переменные класса. Статические методы становятся закрытыми для дочерних классов, но их возможно переопределять.
```php
class MathHelper {
    public static function square(int $number): int {
        return $number * $number;
    }
}

echo MathHelper::square(5); // использование: выведет 25
```

Переменные.
Вызов обычной переменной/метода 
```php
public $name;
//...
echo $this->name;
```

Вызов статической переменной/метода
```php
static $name;
//...
echo self::$name;
```


Пример использования статической переменной
```php
class Human
{
    private static $count = 0;
    public static function getCount()
    {
        return self::$count;
    }
}

echo 'Людей уже ' . Human::getCount(); // 0
```
  
  
  Еще про static тут [OOP в картинках](OOP%20в%20картинках.excalidraw.md#^3SoR44os)   и тут [Функции в PHP](Функции%20в%20PHP.md)

