#php/ооп 

Нужны для того чтобы описывать контракты при работе с классами.  

### Абстрактные классы
описывает список необходимых в классе свойств (foldable) и методов(fold).  От aбстрактных классов невозможно создать экземпляр объекта, только дочерний класс.  **Используется когда нужно общее поведение + контракт.**
- Абстрактные методы нужно указывать явно с помощью ключевого слова `abstract`;
- Абстрактные методы нужно объявлять с идентификаторами доступа (`public, protected, privat`). При реализации класс потомок должен иметь такой же модификатор или менее ограниченный.
- Может содержать методы с реализацией, данные, константы
- В PHP нет множественного наследования, класс может наследовать только один абстрактный класс
```php
abstract class Animal {
    protected string $name;

    public function __construct(string $name) {
        $this->name = $name;
    }

    abstract public function makeSound();  //заставляем дочерние классы обязательно реализовать makeSound()
    
    public function getName() {  //задаём общую реализацию
        return $this->name;
    }
}

class Dog extends Animal {
    public function makeSound() {  
        return "Гав!";
    }
}
```


### Интерфейс 
описывает **контракт** наследников , но зато позволяет наследовать от нескольких интерфейсов.
- Все методы публичные, но не могут содержать реализации(только контракт без кода)
- Может содержать только константы и методы
- Класс может наследовать много интерфейсов

Пример интерфейса
```php
interface CalculateSquare
{
    public function calculateSquare(): float;  //все методы публичные
    //таких методов может быть несколько, все эти методы классы должны будут реализовать
}

class Circle implements CalculateSquare  //после слова implements класс должен будет содержать реализацию метода calculateSquare и других методов
{
    ...
}

class Circle implements CalculateSquare, Interface2, Interface3  //один класс может реализовывать сразу несколько интерфейсов
{ 
... 
}

$circle1 = new Circle(2.5); 
var_dump($circle1 instanceof CalculateSquare); //true  
```

Интерфейсы - это не просто список методов. Интерфейс задаёт контракт, ты обязываешь класс не только иметь нужный метод, но и чтобы в нем была реализация метода. А  *instanceof* задает принадлежность к архитектурной-роли которую мы выделили для класса.  Плюс конструкция *interface*  и *instanceof*  помогает IDE контролировать контракт. 

Просто проверить наличие метода можно через рефлексию
```php
$rc = new ReflectionClass($object);
$methods = $rc->getMethods();
```


### Final класс и метод
Делает все наоборот. Запрещает переопределение для класса или метода. Полезно когда мы хотим защитить метод родителя, чтобы потом его можно было расширять не оглядываясь на возможные дочерние переопределения. 