# Подзапросы

**Подзапросы** - это запросы внутри запросов. Они позволяют использовать результат одного запроса внутри другого запроса.
Подзапрос можно использовать как простое значение или как набор значений. В первом случае обязательно, чтобы подзапрос возвращал не больше одной строки и только один столбец
```sql
SELECT emp.name AS employee
FROM employees AS emp
WHERE emp.department_id IN (
    SELECT dep.department_id
    FROM departments AS dep
    WHERE dep.city = 'Vladivostok'
);
```

Если подзапрос обращается к полям основного запроса, то его называют **коррелированным**. Такие подзапросы запускаются заново для каждой строки основного запроса, и общее время выполнения может быть очень большим.

Подзапросы можно использовать для пред фильтрации JOIN. Пример
```sql
SELECT *
FROM
  (SELECT * FROM products WHERE price > 100) AS p
CROSS JOIN
  (SELECT * FROM categories WHERE active = 1) AS c
```

# Соединения / JOIN
Способ составления сложные запросов через все виды JOIN-ов. Самый типичный случай использования `JOIN` - это связывание таблиц через внешний ключ. Есть много запросов которые можно решить как через JOIN так и через подзапросы. 

Как происходит процесс вычисления у **соединения**:
1. СУБД строит связь между таблицами.
2. Выполняется фильтрация по условию.
3. Из результата возвращается нужные столбцы.

Для сравнения у подзапросов:
4. Находится нужный идентификатор.
5. Для каждой строки основного запроса выполняется подзапрос.

Итого: 
- Подзапросы могут быть экономичнее, но на практике разница может быть минимальной. 
- На больших объемах данных надо использовать соединения. 

# CTE / Common Table Expressions / обобщенные табличные выражения / WITH AS

Синтаксис CTE:
```sql
WITH <CTE-Name> AS (
    <CTE-Query>
)
<Main-Query>
```

Пример. Запрос который достает 50 лучших книг по значению средней оценки. И дополнительно исключает книги с возрастным рейтингом 18+.

```sql
WITH user_filtered_books AS ( -- объявляем CTE
    -- запрос, который отбирает книги по индивидуальному фильтру
  SELECT *
  FROM books AS bk
  WHERE bk.age_rating <> '18+'
)

-- запрос, который формирует подборку
SELECT ufb.title
FROM user_filtered_books AS ufb -- используем CTE
WHERE ufb.genre = 'Роман'
ORDER BY ufb.users_score DESC
LIMIT 50
```

Конструкций `WITH .. AS (),`  можно добавлять любое количество через запятую перед основным запросом. Через имя CTE можно ссылаться как в основном запросе, так и в других CTE, в том числе в первоначальном порождая рекурсию.  

Преимущества:
- код более читаемый потому что CTE описан до основного запроса а не внутри него.
- можно переиспользовать запросы обращаясь по имени
- поддержка рекурсии (единственный способ сделать рекурсию в SQL)
- производительность одинаковая по сравнению в вложенными запросами 

# Представления / VIEW 
**VIEW** - это сохранённый SQL-запрос, который можно использовать как таблицу. Он создаётся один раз и доступен в любой момент, как обычная таблица.
- можно переиспользовать в других запросах
- сохраняется в БД, можно добавить отдельный доступ
- удобно для читаймости разделяет код запроса на подзапросы

Пример
```sql
CREATE VIEW expensive_products AS
SELECT * FROM products WHERE price > 1000;

-- Использование:
SELECT name FROM expensive_products WHERE stock > 10;
```

Еще пример с запросом топа книг за исключением 18+
```sql
DROP VIEW IF EXISTS books_for_non_adult;  --удалить если были предыдущие запуски кода

CREATE VIEW books_for_non_adult AS
SELECT *
FROM books AS bk
WHERE bk.age_rating <> '18+';

SELECT bfna.title
FROM books_for_non_adult AS bfna -- используем VIEW
WHERE bfna.genre = 'Роман'
ORDER BY bfna.users_score DESC
LIMIT 10
```




# Материализованные представления / MATERIALIZED VIEW
Обычный `VIEW` вычисляется  и подставляется в запрос при каждом запросе. А `MATERIALIZED VIEW` вычисляется и результат хранит на диске как таблица. 

Обновляется отдельной командой  `REFRESH`.  По сути является полным аналогом отдельной таблицы,  только с более простым обновлением данных.  Можно даже добавить индексы и права доступа. В итоге данные не всегда актуальные, но зато отдаются быстро.

```sql
CREATE MATERIALIZED VIEW top_sales_mat AS
SELECT * FROM sales WHERE total > 1000;

-- работает быстро: данные уже сохранены
SELECT * FROM top_sales_mat;

-- чтобы обновить данные:
REFRESH MATERIALIZED VIEW top_sales_mat;
```

# Сравнение и где кого использовать

### Подзапросы
**Когда использовать:**
- Простая логика, однократное использование
- Фильтрация, агрегация, сортировка внутри `SELECT`, `WHERE`, `FROM`
- Вложенность не превышает 1–2 уровня
**Не подходит:**
- Для многократного использования
- Для сложной логики

### JOIN
**Когда использовать:**
- Объединение таблиц по логике (напр., `user` + `orders`)
- Когда нужны поля из нескольких таблиц
**Не подходит:**
- Для декомпозиции сложной логики - делает запросы громоздкими

### CTE (`WITH`)
**Когда использовать:**
- Сложная логика, которую нужно разбить на этапы
- Повторное использование промежуточных выборок в одном запросе
- Рекурсивные запросы

**Не подходит:**
- Для постоянного многократного использования во многих запросах

### VIEW
**Когда использовать:**
- Повторяющаяся бизнес-логика (например, топ-продажи, активные пользователи)
- Чтение данных с постоянной структурой
- Централизация логики (единый источник истины)

**Не подходит:**
- Когда данные нужно часто обновлять вручную или накапливать
- При тяжёлых запросах с большой нагрузкой

### MATERIALIZED VIEW
**Когда использовать:**
- Часто используемые, **тяжёлые** запросы
- Когда можно обновлять данные по расписанию (например, раз в час)
- Нужно ускорить SELECT

**Не подходит:**
- Когда нужна высокая актуальность (например, онлайн-данные)
- Когда данные часто меняются

###  Отдельная таблица
**Когда использовать:**
- Необходим полный контроль над наполнением
- Частые записи/обновления
- Поступают внешние данные, не из SQL-запросов
- Нужно накапливать/обогащать данные вручную

**Не подходит:**
- Для простой выборки, которую можно автоматизировать
- Если есть риск нарушения синхронизации

#sql #php/db
