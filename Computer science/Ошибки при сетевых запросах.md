
## Подготовка запроса
### Неправильный URL/домен
**Проверка:** убедиться, что URL валиден и ведёт на ожидаемый хост.
**Диагностика:** открыть URL в адресной строке или выполнить fetch и поймать TypeError.
```js
fetch('https://example.com/yourPath') 
  .then(r => console.log('status', r.status))
  .catch(e => console.error('URL/Network error', e));
```
### Неверный HTTP-метод
**Проверка:** сравнить требуемый метод с тем, что используется сервером.
**Диагностика:** вызвать с другим методом и посмотреть ответ/логи сервера.
```js
fetch('/api/resource', { method: 'POST' })
  .then(r => console.log(r.status))
  .catch(console.error);
```
### Неправильные заголовки (Content-Type, Authorization)
**Проверка:** смотреть запрос в DevTools → Network; сервер может отвергать отсутствие Authorization.
**Диагностика:** явно установить заголовки и проверить ответ.
```js
fetch('/api', { 
  method: 'POST',
  headers: { 
	  'Content-Type': 'application/json', 
	  'Authorization': 'Bearer TOKEN' 
  },
  body: JSON.stringify({a:1})
})
.then(r => console.log(r.status, r.headers.get('content-type')))
.catch(console.error);
```
### Неправильное тело запроса
**Проверка:** сериализация соответствует ожиданиям сервера (JSON vs FormData).
**Диагностика:** отправить минимальный корректный payload и посмотреть в DevTools/серверных логах.
```js
const payload = JSON.stringify({name:'A'});
fetch('/api', { 
	method:'POST', 
	body: payload, 
	headers: {
			'Content-Type':'application/json'
		}
	})
	.then(r => r.text().then(t => console.log('resp', t)))
	.catch(console.error);
```
### Кодировка и BOM в теле/ответе
**Проверка:** смотреть Content-Type charset; BOM может ломать JSON.parse.
**Диагностика:** получить текст и проверить первые байты.
```js
fetch('/api')
  .then(r => r.text())
  .then(t => console.log('startsWith BOM?', t.charCodeAt(0) === 0xFEFF, t.slice(0,50)))
  .catch(console.error);
```
### URL-параметры и кодирование
**Проверка:** encodeURIComponent для значений; проверьте final URL в Network.
**Диагностика:** собрать URL вручную и сравнить.
```js
const q = 'тест &/=?';
const url = '/search?q=' + encodeURIComponent(q);
fetch(url).then(r => console.log(r.status)).catch(console.error);
```
### Mode / credentials / no-cors
**Проверка:** неправильный mode/credentials приведёт к ограниченному запросу/отсутствию cookie.
**Диагностика:** явно задать credentials и смотреть cookies в запросе.
```js
fetch('/api', { credentials: 'include' })
  .then(r => console.log('status', r.status))
  .catch(console.error);
```
### Timeout / долгие запросы (fetch не имеет таймаута)
**Проверка:** использовать AbortController для таймаута и измерять латентность.
**Диагностика:** прерывать при превышении лимита.
```js
const ac = new AbortController();
const t = setTimeout(()=> ac.abort(), 5000);
fetch('/slow', { signal: ac.signal })
  .then(r => { clearTimeout(t); return r; })
  .catch(e => console.error('timeout/abort?', e.name));
```

## Сеть / транспорт
### Нет соединения / DNS / сетевые проблемы
**Проверка:** в DevTools → Network видно статус `Failed` или ошибки в консоли; попытка открыть сайт в новой вкладке.
**Диагностика:** проверка `navigator.onLine` и простого fetch на известный адрес.
```js
console.log('navigator.onLine', navigator.onLine);
fetch('https://example.com').catch(e => console.error('network error', e));
```
### TLS/SSL ошибки
**Проверка:** браузер показывает блокировку (lock icon); в консоли будут ошибки безопасности.
**Диагностика:** открыть URL в адресной строке и посмотреть предупреждение сертификата.
### Firewalls / корпоративные прокси
**Проверка:** если другие сайты доступны, но API — нет; DevTools/OS-level proxy settings.
**Диагностика:** попробовать запрос через curl на той же машине (внешне), или временно отключить VPN/proxy.

## CORS и политика безопасности браузера
### CORS (Access-Control-Allow- / Mixed content
**Проверка:** если в консоли "Access-Control-Allow-Origin" или preflight ошибки — CORS.
**Диагностика:** смотреть preflight (OPTIONS) в Network; запрос в том же домене обычно проходит.

> **Preflight-запрос (или OPTIONS)** — это предварительный HTTP-запрос, использующий метод OPTIONS, который браузер отправляет перед "сложным" кросс-доменным запросом. Его цель — узнать у сервера, разрешены ли ему определенные методы, заголовки и тип запроса. Если сервер в своем OPTIONS-ответе разрешит запрос, то браузер отправит основной запрос; в противном случае, он не будет отправлен, и браузер покажет CORS-ошибку.

```js
fetch('https://api.other-domain.com/data')
  .then(r => console.log('ok?', r.ok))
  .catch(e => console.error('CORS/Network error', e));
```
### Preflight (OPTIONS) возвращает ошибку
**Проверка:** найти OPTIONS в Network; посмотреть статус и заголовки `Access-Control-Allow-*`.
**Диагностика:** выполнить fetch с нестандартным заголовком, посмотреть OPTIONS.
```js
fetch('/api', { 
	method:'POST', 
	headers: { 'X-Test': '1' }, 
	body: '{}' }
	)
	.catch(e => console.error('preflight/other error', e));
```
### CSP блокирует fetch
**Проверка:** ошибки CSP в консоли (Refused to connect).
**Диагностика:** временно отключить CSP или проверить `header Content-Security-Policy` на сервере.

## Серверные ошибки и поведение
### Сервер возвращает 4xx / 5xx
**4xx (401, 403, 404, 422)** — проблема с аутентификацией/авторизацией/валидностью URL/данных
**5xx (500, 502, 503, 504)** — внутренняя ошибка, перегрузка, gateway/proxy error

**Проверка:** проверять response.status и response.ok; смотреть тело ошибки.
**Диагностика:** вывести статус и текст.
```js
fetch('/api')
  .then(async r => {
    console.log('status', r.status);
    const t = await r.text();
    console.log('body', t);
  })
  .catch(console.error);
```
### Редиректы (3xx) и смена метода/кредов
**Проверка:** в Network смотрите redirect chain; fetch следуют редиректам по умолчанию.
**Диагностика:** отключить redirect-following через redirect:'manual' чтобы увидеть Location.
```js
fetch('/maybe-redirect', { redirect: 'manual' })
  .then(r => console.log('status', r.status, 'location', r.headers.get('Location')))
  .catch(console.error);
```
### Некорректный Content-Type в ответе
**Проверка:** r.headers.get('content-type'); если не тот, не вызывать response.json().
**Диагностика:** читать текст и смотреть первые символы.
```js
fetch('/api')
  .then(r => {
    console.log('ct', r.headers.get('content-type'));
    return r.text();
  })
  .then(t => console.log(t.slice(0,100)))
  .catch(console.error);
```
### Chunked/streamed ответ обрывается
**Проверка:** Network покажет truncated/ERR_CONNECTION_RESET или частичную длину.
**Диагностика:** читать поток и фиксировать момент ошибки (catch на read()).

## Парсинг ответа и формат данных

### response.json() бросает ошибку (некорректный JSON)
**Проверка:** ловить ошибку при парсинге.
**Диагностика:** сначала получить текст, потом JSON.parse в try/catch, показать проблему.
```js
fetch('/api')
  .then(r => r.text())
  .then(t => {
    try { console.log(JSON.parse(t)); }
    catch(e) { console.error('bad json', e, t.slice(0,200)); }
  })
  .catch(console.error);
```
### Большие ответы / Out Of Memory / main-thread блокировка
**Проверка:** если браузер зависает при response.json(), ответ может быть слишком большим.
**Диагностика:** использовать потоковый read() вместо .json() и читать по частям.
```js
fetch('/big')
  .then(r => {
    const reader = r.body.getReader();
    return reader.read().then(function process({done, value}) {
      if(done) return console.log('done');
      console.log('chunk', value.byteLength);
      return reader.read().then(process);
    });
  })
  .catch(console.error);
```
## Обработка ответа в коде (логика клиента)
### Race conditions / устаревшие ответы
**Проверка:** пометить запросы последовательными id и игнорировать старые ответы.
**Диагностика:** добавить номеровку и логировать когда ответ применён.
```js
let last = 0;
async function load(q){
  const id = ++last;
  const r = await fetch('/search?q=' + encodeURIComponent(q));
  const data = await r.json();
  if(id !== last) return console.log('stale', id);
  console.log('apply', data);
}
```
### Неправильная обработка ошибок промисов
**Проверка:** всегда `.catch()` или `try`/`catch` вокруг `await`.
**Диагностика:** пример с `try`/`catch`.
```js
async function req(){ 
  try {
    const r = await fetch('/api');
    if(!r.ok) throw new Error('status ' + r.status);
    console.log(await r.json());
  } catch(e){ console.error('fetch error', e); }
}
req();
```

## Резервирование и отказоустойчивость
### Retry / backoff неверно настроены
**Проверка:** не делать retry на 4xx, использовать экспоненциальный backoff + jitter.
**Диагностика:** логировать попытки; вот простой retry-пример:
```js
async function fetchWithRetry(url, tries=3){
  for(let i=0;i<tries;i++){
    try { return await fetch(url); }
    catch(e){ console.warn('attempt', i+1, 'failed', e); await new Promise(r=>setTimeout(r, 1000*(i+1))); }
  }
  throw new Error('all retries failed');
}
```
### Кэширование (старые данные)
**Проверка:** смотреть заголовки Cache-Control; в fetch указывать cache:'no-store' для обхода.
**Диагностика:**
```js
fetch('/api', 
	{ cache: 'no-store' }
	)
	.then(r => console.log(r.status))
	.catch(console.error);
```


## Безопасность и приватность
### CSRF/ Cross-Site Request Forgery / межсайтовая подделка запроса / cookie auth проблемы
**Проверка:** не помещать секреты в query; если сервер использует cookie для auth, убедитесь `credentials:'include'` и CSRF-токен.
**Диагностика:** проверить в Network, отправляются ли cookie.
```js
fetch('/private', 
	{ credentials: 'include' }
	)
	.then(r => console.log(r.status))
	.catch(console.error);
```

## Инструменты и окружение
### Service Worker / devtools mocks вмешиваются
**Проверка:** в Application → Service Workers увидеть активные worker'ы; отключить и повторить.
**Диагностика:** unregister SW в DevTools или открыть в incognito (без SW).
### Неправильные заголовки ответа HSTS/TLS влияющие на поведение
**Проверка:** смотреть response headers; HSTS/TLS директивы видны в Network.
**Диагностика:** проверить заголовки headers в ответе.
### Расхождения между браузерами / polyfills
**Проверка:** Попробовать тот же запрос в другом браузере



